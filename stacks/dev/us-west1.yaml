# Atmos Stack Configuration for Dev Environment - us-west1 (Oregon)
# This file orchestrates all components for the development environment

# Import base configurations (if any)
import: []

# Stack-level variables for Atmos
vars:
  environment: dev
  region: us-west1

# Component configurations
components:
  terraform:
    # GCP Project Component
    gcp-project:
      metadata:
        component: gcp-project
        inherits: []
      vars:
        project_name: "SMC Atmos Test"
        project_id: "smc-atmos-test-00"
        org_id: "933250405420"
        billing_account: "000000-000002-6D3BF8"
        labels:
          environment: "dev"
          managed_by: "terraform"
          project: "atmos-testdrive"
        enabled_apis:
          - "compute.googleapis.com"
          - "cloudresourcemanager.googleapis.com"
          - "logging.googleapis.com"
          - "monitoring.googleapis.com"
          - "iap.googleapis.com"

    # VPC Network Component
    vpc:
      metadata:
        component: vpc
        inherits: []
      vars:
        project_id: "smc-atmos-test-00"
        network_name: "smc-atmos-vpc-00"
        routing_mode: "REGIONAL"
        description: "VPC network for Atmos test drive"

    # Subnet Component
    subnet:
      metadata:
        component: subnet
        inherits: []
      vars:
        project_id: "smc-atmos-test-00"
        subnet_name: "smc-atmos-subnet-00"
        region: "us-west1"
        network_name: "smc-atmos-vpc-00"
        ip_cidr_range: "10.0.0.0/24"
        private_ip_google_access: true
        description: "Subnet for Atmos test drive in us-west1"
        # Verbose logging configuration
        flow_logs_interval: "INTERVAL_5_SEC"
        flow_logs_sampling: 1.0
        flow_logs_metadata: "INCLUDE_ALL_METADATA"

    # Firewall Rules Component
    firewall:
      metadata:
        component: firewall
        inherits: []
      vars:
        project_id: "smc-atmos-test-00"
        network_name: "smc-atmos-vpc-00"
        name_prefix: "smc-atmos"

    # VM Instance Component
    vm:
      metadata:
        component: vm
        inherits: []
      vars:
        project_id: "smc-atmos-test-00"
        instance_name: "smc-atmos-vm-00"
        zone: "us-west1-a"
        machine_type: "e2-micro"
        network_name: "smc-atmos-vpc-00"
        subnet_name: "smc-atmos-subnet-00"
        network_tags:
          - "http-server"
        boot_disk_image: "debian-cloud/debian-12"
        boot_disk_size: 10
        boot_disk_type: "pd-standard"
        startup_script: |
          #!/bin/bash
          # VM Startup Script for GCE Instance
          set -e

          # Log all output
          exec > >(tee /var/log/startup-script.log)
          exec 2>&1

          echo "========================================"
          echo "Starting VM setup at $(date)"
          echo "========================================"

          # Update system packages
          echo "Updating system packages..."
          apt-get update
          apt-get upgrade -y

          # Install required packages
          echo "Installing required packages..."
          apt-get install -y wget git curl

          # Install Go
          echo "Installing Go..."
          GO_VERSION="1.21.5"
          wget -q https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz
          rm -rf /usr/local/go
          tar -C /usr/local -xzf go${GO_VERSION}.linux-amd64.tar.gz
          rm go${GO_VERSION}.linux-amd64.tar.gz

          # Set Go environment variables
          export PATH=$PATH:/usr/local/go/bin
          export GOPATH=/root/go

          # Verify Go installation
          echo "Go version: $(go version)"

          # Create application directory
          echo "Creating application directory..."
          mkdir -p /opt/webapp
          cd /opt/webapp

          # Create the Go application (embedded inline)
          echo "Creating Go application..."
          cat > main.go << 'GOEOF'
          package main

          import (
            "encoding/json"
            "fmt"
            "io"
            "log"
            "net/http"
            "os"
          )

          const metadataURL = "http://metadata.google.internal/computeMetadata/v1"

          type VMMetadata struct {
            InstanceName string
            InstanceID   string
            Zone         string
            ProjectID    string
            MachineType  string
            InternalIP   string
            ExternalIP   string
            Hostname     string
          }

          func getMetadata(path string) (string, error) {
            client := &http.Client{}
            req, err := http.NewRequest("GET", metadataURL+path, nil)
            if err != nil {
              return "", err
            }
            req.Header.Add("Metadata-Flavor", "Google")
            resp, err := client.Do(req)
            if err != nil {
              return "", err
            }
            defer resp.Body.Close()
            body, err := io.ReadAll(resp.Body)
            if err != nil {
              return "", err
            }
            return string(body), nil
          }

          func fetchVMMetadata() (*VMMetadata, error) {
            metadata := &VMMetadata{}
            if val, err := getMetadata("/instance/name"); err == nil {
              metadata.InstanceName = val
            }
            if val, err := getMetadata("/instance/id"); err == nil {
              metadata.InstanceID = val
            }
            if val, err := getMetadata("/instance/zone"); err == nil {
              metadata.Zone = val
            }
            if val, err := getMetadata("/project/project-id"); err == nil {
              metadata.ProjectID = val
            }
            if val, err := getMetadata("/instance/machine-type"); err == nil {
              metadata.MachineType = val
            }
            if val, err := getMetadata("/instance/network-interfaces/0/ip"); err == nil {
              metadata.InternalIP = val
            }
            if val, err := getMetadata("/instance/network-interfaces/0/access-configs/0/external-ip"); err == nil {
              metadata.ExternalIP = val
            } else {
              metadata.ExternalIP = "None"
            }
            if val, err := getMetadata("/instance/hostname"); err == nil {
              metadata.Hostname = val
            }
            return metadata, nil
          }

          func handleRoot(w http.ResponseWriter, r *http.Request) {
            metadata, err := fetchVMMetadata()
            if err != nil {
              http.Error(w, fmt.Sprintf("Error fetching metadata: %v", err), http.StatusInternalServerError)
              return
            }
            w.Header().Set("Content-Type", "text/html; charset=utf-8")
            html := fmt.Sprintf(`<!DOCTYPE html><html><head><title>GCE Instance Info</title><style>body{font-family:'Segoe UI',sans-serif;max-width:800px;margin:50px auto;padding:20px;background-color:#f5f5f5}.container{background-color:white;border-radius:8px;padding:30px;box-shadow:0 2px 4px rgba(0,0,0,0.1)}h1{color:#4285f4;border-bottom:3px solid #4285f4;padding-bottom:10px}.info-grid{display:grid;grid-template-columns:200px 1fr;gap:15px;margin-top:20px}.label{font-weight:bold;color:#555}.value{color:#333;font-family:'Courier New',monospace;background-color:#f8f9fa;padding:5px 10px;border-radius:4px}.footer{margin-top:30px;padding-top:20px;border-top:1px solid #ddd;text-align:center;color:#666;font-size:14px}</style></head><body><div class="container"><h1>GCE Instance Information</h1><p>This page displays metadata about the Google Compute Engine instance it's running on.</p><div class="info-grid"><div class="label">Instance Name:</div><div class="value">%s</div><div class="label">Instance ID:</div><div class="value">%s</div><div class="label">Zone:</div><div class="value">%s</div><div class="label">Project ID:</div><div class="value">%s</div><div class="label">Machine Type:</div><div class="value">%s</div><div class="label">Internal IP:</div><div class="value">%s</div><div class="label">External IP:</div><div class="value">%s</div><div class="label">Hostname:</div><div class="value">%s</div></div><div class="footer"><p>Powered by Go â€¢ Deployed with Terraform + Atmos</p></div></div></body></html>`, metadata.InstanceName, metadata.InstanceID, metadata.Zone, metadata.ProjectID, metadata.MachineType, metadata.InternalIP, metadata.ExternalIP, metadata.Hostname)
            fmt.Fprint(w, html)
          }

          func handleJSON(w http.ResponseWriter, r *http.Request) {
            metadata, err := fetchVMMetadata()
            if err != nil {
              http.Error(w, fmt.Sprintf("Error fetching metadata: %v", err), http.StatusInternalServerError)
              return
            }
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(metadata)
          }

          func handleHealth(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            fmt.Fprint(w, "OK")
          }

          func main() {
            http.HandleFunc("/", handleRoot)
            http.HandleFunc("/json", handleJSON)
            http.HandleFunc("/health", handleHealth)
            port := "80"
            log.Printf("Starting server on port %s...", port)
            if err := http.ListenAndServe(":"+port, nil); err != nil {
              log.Fatal(err)
            }
          }
          GOEOF

          # Initialize Go module
          echo "Initializing Go module..."
          go mod init webapp

          # Build the application
          echo "Building Go application..."
          go build -o webapp main.go

          # Create systemd service
          cat > /etc/systemd/system/webapp.service << 'EOF'
          [Unit]
          Description=GCE Metadata Web Application
          After=network.target

          [Service]
          Type=simple
          User=root
          WorkingDirectory=/opt/webapp
          ExecStart=/opt/webapp/webapp
          Restart=always
          RestartSec=5
          StandardOutput=append:/var/log/webapp.log
          StandardError=append:/var/log/webapp-error.log

          [Install]
          WantedBy=multi-user.target
          EOF

          # Start service
          systemctl daemon-reload
          systemctl enable webapp.service
          systemctl start webapp.service

          echo "VM setup completed at $(date)"
        service_account_email: ""
        service_account_scopes:
          - "cloud-platform"
        labels:
          environment: "dev"
          managed_by: "terraform"
          application: "metadata-webapp"
